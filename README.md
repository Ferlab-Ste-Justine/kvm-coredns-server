# About

This module provision coredns instances on kvm.

The server is configured to to work with zonefiles which are fetched from an etcd cluster. Each domain is a key in etcd (with an optional prefix) and the zonefile (which should be compatible with the auto plugin) is the value.

The server will automatically detect any changes in the domains in the etcd backend and update the zonefiles accordingly.

Note that except for updates to zonefiles, the coredns server is decoupled from the etcd cluster and will happily keep answering dns requests with whatever zonefiles it has on hand (they just won't update until the etcd cluster is back up).

# Note About Alternatives

Coredns also has a SkyDNS compatible plugin: https://coredns.io/plugins/etcd/

Some of the perceived pros of the above plugin:
- Assuming that the cache plugin isn't used (ie, all dns requests hit etcd), the consistency level of the answer from different dns servers shortly after the change can't be matched
- From what I read in the readme, decentralisation of ip registration seems better supported out of the box (you could support it with zonefiles too, but extra logic would have to be added using something like templates)

Some of the perceived pros of our implementation:
- Full support for zonefiles to the extend the coredns auto plugin supports them (ie, fewer quirks)
- Decent consistency/performance tradeoff: The server does a watch for changes on the etcd cluster (but will not put any more stress than that etcd) and will automatically update its local zonefiles with changes. The refresh interval set in the auto plugin will determine how quickly those changes will be picked up (3 seconds by default)
- Greater decoupling from etcd: The server is only dependent on etcd for updating zonefiles. If etcd is down, it can still answer queries with the zonefiles it has. 

# Related Projects

See the following terraform module that uploads very basic zonefiles in etcd: https://github.com/Ferlab-Ste-Justine/etcd-zonefile

Also, this module expects to authentify against etcd using tls certificate authentication. The following terraform module will, taking a certificate authority as input, generate a valid key and certificate for a given etcd user (disregard the openstack in the name): https://github.com/Ferlab-Ste-Justine/openstack-etcd-client-certificate

# Supported Networking

The module supports libvirt networks and macvtap (bridge mode).

# Usage

## Input

- **name**: Name of the vm
- **vcpus**: Number of vcpus to assign to the vm. Defaults to 2.
- **memory**: Amount of memory in MiB to assign to the vm. Defaults to 8192 (ie, 8 GiB).
- **volume_id**: Id of the image volume to attach to the vm. A recent version of ubuntu is recommended as this is what this module has been validated against.
- **network_id**: Id (ie, uuid) of the libvirt network to connect the vm to if you wish to connect the vm to a libvirt network.
- **macvtap_interface**: Host network interface that you plan to connect your vm to via a lower macvtap interface. Note that either this or network_id should be set, but not both.
- **macvtap_vm_interface_name_match**: Expected pattern of the network interface name in the vm. Defaults to "en*". Used with macvtap only.
- **macvtap_subnet_prefix_length**: Length of the subnet prefix (ie, the yy in xxx.xxx.xxx.xxx/yy) in the host network. Used with macvtap only
- **macvtap_gateway_ip**: Ip of the host network's gateway. Used with macvtap only.
- **macvtap_dns_servers**: Ip of dns servers that the vm should explicitly use, useful mostly during the initial cloud-init bootstraping to resolve domain of installables. Used for macvtap only.
- **ip**: Ip of the vm on whichever network it is connected. Note that this isn't an optional parameter. Dhcp cannot be used.
- **mac**: Mac address of the vm. If none is passed, a random one will be generated.
- **cloud_init_volume_pool**: Name of the volume pool that will contain the cloud-init volume of the vm.
- **cloud_init_volume_name**: Name of the cloud-init volume that will be generated by the module for your vm. If left empty, it will default to ```<name>-cloud-init.iso```.
- **ssh_admin_user**: Username of the default sudo user in the image. Defaults to **ubuntu**.
- **admin_user_password**: Optional password for the default sudo user of the image. Note that this will not enable ssh password connections, but it will allow you to log into the vm from the host using the **virsh console** command.
- **ssh_admin_public_key**: Public part of the ssh key the admin will be able to login as
- **etcd_ca_certificate**: Tls ca certificate that will be used to validate the authenticity of the etcd cluster
- **etcd_client_certificate**: Tls client certificate for the etcd user the server will authentify as
- **etcd_client_key**: Tls client key for the etcd user the server will authentify as
- **etcd_key_prefix**: Prefix for all the domain keys. The server will look for keys with this prefix and will remove this prefix from the key's name to get the domain.
- **etcd_endpoints**: A list of endpoints for the etcd servers, each entry taking the ```<ip>:<port>``` format
- **coredns_version**: Version of coredns to download and run. Defaults to **1.8.6**.
- **zonefiles_reload_interval**: Time interval at which the **auto** plugin should poll the zonefiles for updates. Defaults to **3s** (ie, 3 seconds).
- **load_balance_records**: In the event that an A or AAAA record yields several ips, whether to randomize the returned order or not (with clients that only take the first ip, you can achieve some dns-level load balancing this way). Defaults to **true**.

## Example

Below is an orchestration I ran locally to troubleshoot the module.

```
resource "libvirt_volume" "coredns_alpha" {
  name             = var.coredns_alpha_volume_name
  pool             = libvirt_pool.coredns.name
  // 10 GiB
  size             = 10 * 1024 * 1024 * 1024
  base_volume_pool = var.os_volumes_pool_name
  base_volume_name = var.coredns_os_volume_name
  format = "qcow2"
}

module "coredns_alpha" {
  source = "git::https://github.com/Ferlab-Ste-Justine/kvm-coredns-server.git"
  name = var.coredns_alpha_name
  vcpus = tonumber(var.coredns_alpha_vcpus)
  memory = tonumber(var.coredns_alpha_memory)
  volume_id = libvirt_volume.coredns_alpha.id
  network_id = var.coredns_alpha_network_id
  macvtap_interface = var.coredns_alpha_macvtap_interface
  macvtap_subnet_prefix_length = var.coredns_alpha_macvtap_subnet_prefix_length
  macvtap_gateway_ip = var.coredns_alpha_macvtap_gateway_ip
  macvtap_dns_servers = var.coredns_alpha_macvtap_dns_servers
  ip = var.coredns_alpha_ip
  mac = var.coredns_alpha_mac
  cloud_init_volume_pool = libvirt_pool.coredns.name
  admin_user_password = var.coredns_alpha_admin_password
  ssh_admin_public_key = tls_private_key.coredns_ssh.public_key_openssh
  etcd_ca_certificate = chomp(data.local_file.etcd_ca_cert.content)
  etcd_client_certificate = chomp(data.local_file.etcd_root_cert.content)
  etcd_client_key = chomp(data.local_file.etcd_root_key.content)
  etcd_key_prefix = var.coredns_alpha_etcd_key_prefix
  etcd_endpoints = var.etcd_endpoints
}
```

For how to differentiate between libvirt network and macvtap orchestration, I invite you to look at the example for this project: https://github.com/Ferlab-Ste-Justine/kvm-etcd-server#example

Also, the gotchas for that project applies to this one as well: https://github.com/Ferlab-Ste-Justine/kvm-etcd-server#gotchas